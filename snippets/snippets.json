{
  "concat": {
    "prefix": ".concat",
    "body": [
      "async.concat(['dir1', 'dir2', 'dir3'], fs.readdir, function (err, files) {",
      " // files is now a list of filenames that exist in the 3 directories",
      "});"
    ],
    "description": "async concat method"
  },
  "detect": {
    "prefix": ".detect",
    "body": [
      "async.detect(['file1','file2','file3'], function(filePath, callback) {",
      "\tfs.access(filePath, function(err) {",
      "\t\tcallback(null, !err)",
      "\t});",
      "}, function(err, result) {",
      "// result now equals the first file in the list that exists",
      "});"
    ],
    "description": "async detect method"
  },
  "each": {
    "prefix": ".each",
    "body": [
      "// example 1",

      "// assuming openFiles is an array of file names and saveFile is a function",
      "// to save the modified contents of that file:",

      "async.each(openFiles, saveFile, function(err){",
      "\t// if any of the saves produced an error, err would equal that error",
      "});",

      "// example 2",

      "// assuming openFiles is an array of file names",
      "async.each(openFiles, function(file, callback) {",

      "\t// Perform operation on file here.",
      "\tconsole.log('Processing file ' + file);",

      "\tif( file.length > 32 ) {",
      "\t\tconsole.log('This file name is too long');",
      "\tcallback('File name too long');",
      "\t} else {",
      "\t\t// Do work to process file here",
      "\t\tconsole.log('File processed');",
      "\tcallback();",
      "\t}",
      "}, function(err) {",
      "\t\t// if any of the file processing produced an error, err would equal that error",
      "\tif( err ) {",
      "\t\t// One of the iterations produced an error.",
      "\t\t// All processing will now stop.",
      "\t\tconsole.log('A file failed to process');",
      "\t} else {",
      "\t\tconsole.log('All files have been processed successfully');",
      "\t}",
      "});"
    ],
    "description": "async each method"
  },
  "forEachOf": {
    "prefix": ".forEachOf",
    "body": [
      "var obj = {dev: '/dev.json', test: '/test.json', prod: '/prod.json'};",
      "var configs = {};",

      "async.forEachOf(obj, function (value, key, callback) {",
      "\tfs.readFile(__dirname + value, 'utf8', function (err, data) {",
      "\t\tif (err) return callback(err);",
      "\t\ttry {",
      "\t\t\tconfigs[key] = JSON.parse(data);",
      "\t\t} catch (e) {",
      "\t\t\treturn callback(e);",
      "\t}",
      "\tcallback();",
      "\t});",
      "}, function (err) {",
      "\tif (err) console.error(err.message);",
      "\t// configs is now a map of JSON data",
      "\tdoSomethingWith(configs);",
      "});"
    ],
    "description": "async forEachOf method"
  },
  "every": {
    "prefix": ".every",
    "body": [
      "async.every(['file1','file2','file3'], function(filePath, callback) {",
      "\tfs.access(filePath, function(err) {",
      "\t\tcallback(null, !err)",
      "\t});",
      "}, function(err, result) {",
      "\t// if result is true then every file exists",
      "});"
    ],
    "description": "async every method"
  },
  "filter": {
    "prefix": ".filter",
    "body": [
      "async.filter(['file1','file2','file3'], function(filePath, callback) {",
      "\tfs.access(filePath, function(err) {",
      "\t\tcallback(null, !err)",
      "\t});",
      "}, function(err, results) {",
      "\t// results now equals an array of the existing files",
      "});"
    ],
    "description": "async filter method"
  },
  "groupBy": {
    "prefix": ".groupBy",
    "body": [
      "async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {",
      "\tdb.findById(userId, function(err, user) {",
      "\t\tif (err) return callback(err);",
      "\t\treturn callback(null, user.age);",
      "\t});",
      "}, function(err, result) {",
      "\t// result is object containing the userIds grouped by age",
      "\t// e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};",
      "});"
    ],
    "description": "async groupBy method"
  },
  "map": {
    "prefix": ".map",
    "body": [
      "async.map(['file1','file2','file3'], fs.stat, function(err, results) {",
      "\t// results is now an array of stats for each file",
      "});"
    ],
    "description": "async map method"
  },
  "mapValues": {
    "prefix": ".mapValues",
    "body": [
      "async.mapValues({",
      "\tf1: 'file1',",
      "\tf2: 'file2',",
      "\tf3: 'file3'",
      "}, function (file, key, callback) {",
      "\tfs.stat(file, callback);",
      "}, function(err, result) {",
      "\t// result is now a map of stats for each file, e.g.",
      "\t// {",
      "\t//     f1: [stats for file1],",
      "\t//     f2: [stats for file2],",
      "\t//     f3: [stats for file3]",
      "\t// }",
      "});"
    ],
    "description": "async mapValues method"
  },
  "reduce": {
    "prefix": ".reduce",
    "body": [
      "async.reduce([1,2,3], 0, function(memo, item, callback) {",
      "\t// pointless async:",
      "\tprocess.nextTick(function() {",
      "\t\tcallback(null, memo + item);",
      "\t});",
      "}, function(err, result) {",
      "\t// result is now equal to the last value of memo, which is 6",
      "});"
    ],
    "description": "async reduce method"
  },
  "reject": {
    "prefix": ".reject",
    "body": [
      "async.reject(['file1','file2','file3'], function(filePath, callback) {",
      "\tfs.access(filePath, function(err) {",
      "\t\tcallback(null, !err);",
      "\t});",
      "}, function(err, results) {",
      "\t// results now equals an array of missing files",
      "\tcreateFiles(results);",
      "});"
    ],
    "description": "async reject method"
  },
  "some": {
    "prefix": ".some",
    "body": [
      "async.some(['file1','file2','file3'], function(filePath, callback) {",
      "\tfs.access(filePath, function(err) {",
      "\t\tcallback(null, !err);",
      "\t});",
      "}, function(err, result) {",
      "\t// if result is true then at least one of the files exists",
      "});"
    ],
    "description": "async some method"
  },
  "sortBy": {
    "prefix": ".somesortBy",
    "body": [
      "async.sortBy(['file1','file2','file3'], function(file, callback) {",
      "\tfs.stat(file, function(err, stats) {",
      "\t\tcallback(err, stats.mtime);",
      "\t});",
      "}, function(err, results) {",
      "\t// results is now the original array of files sorted by",
      "\t// modified date",
      "});",

      "// By modifying the callback parameter the",
      "// sorting order can be influenced:",

      "// ascending order",
      "async.sortBy([1,9,3,5], function(x, callback) {",
      "\tcallback(null, x);",
      "}, function(err,result) {",
      "\t// result callback",
      "});",

      "// descending order",
      "async.sortBy([1,9,3,5], function(x, callback) {",
      "\tcallback(null, x*-1);    //<- x*-1 instead of x, turns the order around",
      "}, function(err,result) {",
      "\t// result callback",
      "});"
    ],
    "description": "async sortBy method"
  },
  "sortBy": {
    "prefix": ".somesortBy",
    "body": [
      "// example 1",
      "",
      "async.sortBy(['file1','file2','file3'], function(file, callback) {",
      "\tfs.stat(file, function(err, stats) {",
      "\t\tcallback(err, stats.mtime);",
      "\t});",
      "}, function(err, results) {",
      "\t// results is now the original array of files sorted by",
      "\t// modified date",
      "});",
      "",
      "// By modifying the callback parameter the",
      "// sorting order can be influenced:",

      "// ascending order",
      "async.sortBy([1,9,3,5], function(x, callback) {",
      "\tcallback(null, x);",
      "}, function(err,result) {",
      "\t// result callback",
      "});",

      "// descending order",
      "async.sortBy([1,9,3,5], function(x, callback) {",
      "\tcallback(null, x*-1);    //<- x*-1 instead of x, turns the order around",
      "}, function(err,result) {",
      "\t// result callback",
      "});"
    ],
    "description": "async sortBy method"
  },
  "transform": {
    "prefix": ".transform",
    "body": [
      "// example 1",
      "",
      "async.transform([1,2,3], function(acc, item, index, callback) {",
      "\t// pointless async:",
      "\tprocess.nextTick(function() {",
      "\t\tacc.push(item * 2)",
      "\t\tcallback(null);",
      "\t});",
      "}, function(err, result) {",
      "\t// result is now equal to [2, 4, 6]",
      "});",

      "// example 2",
      "",
      "async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {",
      "\tsetImmediate(function () {",
      "\t\tobj[key] = val * 2;",
      "\t\tcallback();",
      "\t});",
      "}, function (err, result) {",
      "\t// result is equal to {a: 2, b: 4, c: 6}",
      "});"
    ],
    "description": "async transform method"
  },
  "applyEach": {
    "prefix": ".applyEach",
    "body": [
      "async.applyEach([enableSearch, updateSchema], 'bucket', callback);",

      "// partial application example:",
      "async.each(",
      "\tbuckets,",
      "\tasync.applyEach([enableSearch, updateSchema]),",
      "\tcallback",
      ");"
    ],
    "description": "async applyEach method"
  },
  "auto": {
    "prefix": ".auto",
    "body": [
      "async.auto({",
      "\t// this function will just be passed a callback",
      "\treadData: async.apply(fs.readFile, 'data.txt', 'utf-8'),",
      "\tshowData: ['readData', function(results, cb) {",
      "\t\t// results.readData is the file's contents",
      "\t\t// ...",
      "\t}]",
      "}, callback);",

      "async.auto({",
      "\tget_data: function(callback) {",
      "\t\tconsole.log('in get_data');",
      "\t\t// async code to get some data",
      "\t\tcallback(null, 'data', 'converted to array');",
      "\t},",
      "\tmake_folder: function(callback) {",
      "\t\tconsole.log('in make_folder');",
      "\t\t// async code to create a directory to store a file in",
      "\t\t// this is run at the same time as getting the data",
      "\t\tcallback(null, 'folder');",
      "\t},",
      "\twrite_file: ['get_data', 'make_folder', function(results, callback) {",
      "\t\tconsole.log('in write_file', JSON.stringify(results));",
      "\t\t// once there is some data and the directory exists,",
      "\t\t// write the data to a file in the directory",
      "\t\tcallback(null, 'filename');",
      "\t}],",
      "\temail_link: ['write_file', function(results, callback) {",
      "\t\tconsole.log('in email_link', JSON.stringify(results));",
      "\t\t// once the file is written let's email a link to it...",
      "\t\t// results.write_file contains the filename returned by write_file.",
      "\t\tcallback(null, {'file':results.write_file, 'email':'user@example.com'});",
      "\t}]",
      "}, function(err, results) {",
      "\tconsole.log('err = ', err);",
      "\tconsole.log('results = ', results);",
      "});"
    ],
    "description": "async auto method"
  },
  "autoInject": {
    "prefix": ".autoInject",
    "body": [
      "//  The example from `auto` can be rewritten as follows:",
      "async.autoInject({",
      "\tget_data: function(callback) {",
      "\t\t// async code to get some data",
      "\t\tcallback(null, 'data', 'converted to array');",
      "\t},",
      "\tmake_folder: function(callback) {",
      "\t\t// async code to create a directory to store a file in",
      "\t\t// this is run at the same time as getting the data",
      "\t\tcallback(null, 'folder');",
      "\t},",
      "\twrite_file: function(get_data, make_folder, callback) {",
      "\t\t// once there is some data and the directory exists,",
      "\t\t// write the data to a file in the directory",
      "\tcallback(null, 'filename');",
      "\t},",
      "\temail_link: function(write_file, callback) {",
      "\t\t// once the file is written let's email a link to it...",
      "\t\t// write_file contains the filename returned by write_file.",
      "\t\tcallback(null, {'file':write_file, 'email':'user@example.com'});",
      "\t}",
      "}, function(err, results) {",
      "\tconsole.log('err = ', err);",
      "\tconsole.log('email_link = ', results.email_link);",
      "});",

      "// If you are using a JS minifier that mangles parameter names, `autoInject`",
      "// will not work with plain functions, since the parameter names will be",
      "// collapsed to a single letter identifier.  To work around this, you can",
      "// explicitly specify the names of the parameters your task function needs",
      "// in an array, similar to Angular.js dependency injection.",

      "// This still has an advantage over plain `auto`, since the results a task",
      "// depends on are still spread into arguments.",
      "async.autoInject({",
      "\t//...",
      "\twrite_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {",
      "\t\tcallback(null, 'filename');",
      "\t}],",
      "\temail_link: ['write_file', function(write_file, callback) {",
      "\t\tcallback(null, {'file':write_file, 'email':'user@example.com'});",
      "\t}]",
      "\t//...",
      "}, function(err, results) {",
      "\tconsole.log('err = ', err);",
      "\tconsole.log('email_link = ', results.email_link);",
      "});"
    ],
    "description": "async autoInject method"
  },
  "cargo": {
    "prefix": ".cargo",
    "body": [
      "// create a cargo object with payload 2",
      "var cargo = async.cargo(function(tasks, callback) {",
      "\tfor (var i=0; i<tasks.length; i++) {",
      "\t\tconsole.log('hello ' + tasks[i].name);",
      "\t}",
      "\tcallback();",
      "}, 2);",

      "// add some items",
      "cargo.push({name: 'foo'}, function(err) {",
      "\tconsole.log('finished processing foo');",
      "});",
      "cargo.push({name: 'bar'}, function(err) {",
      "\tconsole.log('finished processing bar');",
      "});",
      "cargo.push({name: 'baz'}, function(err) {",
      "\tconsole.log('finished processing baz');",
      "});"
    ],
    "description": "async cargo method"
  },
  "cargo": {
    "prefix": ".compose",
    "body": [
      "function add1(n, callback) {",
      "\tsetTimeout(function () {",
      "\t\tcallback(null, n + 1);",
      "\t}, 10);",
      "}",

      "function mul3(n, callback) {",
      "\tsetTimeout(function () {",
      "\t\tcallback(null, n * 3);",
      "\t}, 10);",
      "}",

      "var add1mul3 = async.compose(mul3, add1);",
      "add1mul3(4, function (err, result) {",
      "\t// result now equals 15",
      "});"
    ],
    "description": "async compose method"
  },
  "during": {
    "prefix": ".during",
    "body": [
      "var count = 0;",

      "async.during(",
      "\tfunction (callback) {",
      "\t\treturn callback(null, count < 5);",
      "\t},",
      "\tfunction (callback) {",
      "\t\tcount++;",
      "\t\tsetTimeout(callback, 1000);",
      "\t},",
      "\tfunction (err) {",
      "\t\t// 5 seconds have passed",
      "\t}",
      ");"
    ],
    "description": "async during method"
  },
  "forever": {
    "prefix": ".forever",
    "body": [
      "async.forever(",
      "\tfunction(next) {",
      "\t\t// next is suitable for passing to things that need a callback(err [, whatever]);",
      "\t\t// it will result in this function being called again.",
      "\t},",
      "\tfunction(err) {",
      "\t\t// if next is called with a value in its first parameter, it will appear",
      "\t\t// in here as 'err', and execution will stop.",
      "\t}",
      ");"
    ],
    "description": "async forever method"
  },
  "parallel": {
    "prefix": ".parallel",
    "body": [
      "async.parallel([",
      "\tfunction(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'one');",
      "\t\t}, 200);",
      "\t},",
      "function(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'two');",
      "\t\t}, 100);",
      "\t}",
      "],",
      "// optional callback",
      "function(err, results) {",
      "\t// the results array will equal ['one','two'] even though",
      "\t// the second function had a shorter timeout.",
      "});",

      "// an example using an object instead of an array",
      "async.parallel({",
      "\tone: function(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 1);",
      "\t\t}, 200);",
      "\t},",
      "\ttwo: function(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 2);",
      "\t\t}, 100);",
      "\t}",
      "}, function(err, results) {",
      "\t// results is now equals to: {one: 1, two: 2}",
      "});"
    ],
    "description": "async parallel method"
  },
  "queue": {
    "prefix": ".queue",
    "body": [
      "// create a queue object with concurrency 2",
      "var q = async.queue(function(task, callback) {",
      "\tconsole.log('hello ' + task.name);",
      "\tcallback();",
      "}, 2);",

      "// assign a callback",
      "q.drain = function() {",
      "\tconsole.log('all items have been processed');",
      "};",

      "// add some items to the queue",
      "q.push({name: 'foo'}, function(err) {",
      "\tconsole.log('finished processing foo');",
      "});",
      "q.push({name: 'bar'}, function (err) {",
      "\tconsole.log('finished processing bar');",
      "});",

      "// add some items to the queue (batch-wise)",
      "q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {",
      "\tconsole.log('finished processing item');",
      "});",

      "// add some items to the front of the queue",
      "q.unshift({name: 'bar'}, function (err) {",
      "\tconsole.log('finished processing bar');",
      "});"
    ],
    "description": "async queue method"
  },
  "race": {
    "prefix": ".race",
    "body": [
      "async.race([",
      "\tfunction(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'one');",
      "\t\t}, 200);",
      "\t},",
      "\tfunction(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'two');",
      "\t\t}, 100);",
      "\t}",
      "],",
      "// main callback",
      "function(err, result) {",
      "\t// the result will be equal to 'two' as it finishes earlier",
      "});"
    ],
    "description": "async race method"
  },
  "retry": {
    "prefix": ".retry",
    "body": [
      "// The `retry` function can be used as a stand-alone control flow by passing",
      "// a callback, as shown below:",

      "// try calling apiMethod 3 times",
      "async.retry(3, apiMethod, function(err, result) {",
      "\t// do something with the result",
      "});",

      "// try calling apiMethod 3 times, waiting 200 ms between each retry",
      "async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {",
      "\t// do something with the result",
      "});",

      "// try calling apiMethod 10 times with exponential backoff",
      "// (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)",
      "async.retry({",
      "\ttimes: 10,",
      "\tinterval: function(retryCount) {",
      "\t\treturn 50 * Math.pow(2, retryCount);",
      "\t}",
      "}, apiMethod, function(err, result) {",
      "\t// do something with the result",
      "});",

      "// try calling apiMethod the default 5 times no delay between each retry",
      "async.retry(apiMethod, function(err, result) {",
      "\t// do something with the result",
      "});",

      "// try calling apiMethod only when error condition satisfies, all other",
      "// errors will abort the retry control flow and return to final callback",
      "async.retry({",
      "\terrorFilter: function(err) {",
      "\t\treturn err.message === 'Temporary error'; // only retry on a specific error",
      "\t}",
      "}, apiMethod, function(err, result) {",
      "\t// do something with the result",
      "});",

      "// to retry individual methods that are not as reliable within other",
      "// control flow functions, use the `retryable` wrapper:",
      "async.auto({",
      "\tusers: api.getUsers.bind(api),",
      "\tpayments: async.retryable(3, api.getPayments.bind(api))",
      "}, function(err, results) {",
      "\t// do something with the results",
      "});"
    ],
    "description": "async retry method"
  },
  "retryable": {
    "prefix": ".retryable",
    "body": [
      "async.retryable({",
      "\tdep1: async.retryable(3, getFromFlakyService),",
      "\tprocess: ['dep1', async.retryable(3, function (results, cb) {",
      "\t\tmaybeProcessData(results.dep1, cb);",
      "\t})]",
      "}, callback);"
    ],
    "description": "async retryable method"
  },
  "seq": {
    "prefix": ".seq",
    "body": [
      "// Requires lodash (or underscore), express3 and dresende's orm2.",
      "// Part of an app, that fetches cats of the logged user.",
      "// This example uses `seq` function to avoid overnesting and error",
      "// handling clutter.",
      "app.get('/cats', function(request, response) {",
      "\tvar User = request.models.User;",
      "\tasync.seq(",
      "\t\t_.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))",
      "\t\tfunction(user, fn) {",
      "\t\t\tuser.getCats(fn);      // 'getCats' has signature (callback(err, data))",
      "\t\t}",
      "\t)(req.session.user_id, function (err, cats) {",
      "\t\tif (err) {",
      "\t\t\tconsole.error(err);",
      "\t\t\tresponse.json({ status: 'error', message: err.message });",
      "\t\t} else {",
      "\t\t\tresponse.json({ status: 'ok', message: 'Cats found', data: cats });",
      "\t\t}",
      "\t});",
      "});"
    ],
    "description": "async seq method"
  },
  "series": {
    "prefix": ".series",
    "body": [
      "async.series([",
      "\tfunction(callback) {",
      "\t\t// do some stuff ...",
      "\t\tcallback(null, 'one');",
      "\t},",
      "\tfunction(callback) {",
      "\t\t// do some more stuff ...",
      "\t\tcallback(null, 'two');",
      "\t}",
      "],",
      "// optional callback",
      "function(err, results) {",
      "\t// results is now equal to ['one', 'two']",
      "});",

      "async.series({",
      "\tone: function(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 1);",
      "\t\t}, 200);",
      "\t},",
      "\ttwo: function(callback){",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 2);",
      "\t\t}, 100);",
      "\t}",
      "}, function(err, results) {",
      "\t// results is now equal to: {one: 1, two: 2}",
      "});"
    ],
    "description": "async series method"
  },
  "times": {
    "prefix": ".times",
    "body": [
      "// Pretend this is some complicated async factory",
      "var createUser = function(id, callback) {",
      "\tcallback(null, {",
      "\t\tid: 'user' + id",
      "\t});",
      "};",

      "// generate 5 users",
      "async.times(5, function(n, next) {",
      "\tcreateUser(n, function(err, user) {",
      "\t\tnext(err, user);",
      "\t});",
      "}, function(err, users) {",
      "\t// we should now have 5 users",
      "});"
    ],
    "description": "async times method"
  },
  "tryEach": {
    "prefix": ".tryEach",
    "body": [
      "async.tryEach([",
      "\tfunction getDataFromFirstWebsite(callback) {",
      "\t\t// Try getting the data from the first website",
      "\t\tcallback(err, data);",
      "\t},",
      "\tfunction getDataFromSecondWebsite(callback) {",
      "\t\t// First website failed,",
      "\t\t// Try getting the data from the backup website",
      "\t\tcallback(err, data);",
      "\t}",
      "],",
      "// optional callback",
      "function(err, results) {",
      "\tNow do something with the data.",
      "});"
    ],
    "description": "async tryEach method"
  },
  "waterfall": {
    "prefix": ".waterfall",
    "body": [
      "async.waterfall([",
      "\tfunction(callback) {",
      "\t\tcallback(null, 'one', 'two');",
      "\t},",
      "\tfunction(arg1, arg2, callback) {",
      "\t\t// arg1 now equals 'one' and arg2 now equals 'two'",
      "\t\tcallback(null, 'three');",
      "\t},",
      "\tfunction(arg1, callback) {",
      "\t\t// arg1 now equals 'three'",
      "\t\tcallback(null, 'done');",
      "\t}",
      "], function (err, result) {",
      "\t// result now equals 'done'",
      "});",

      "// Or, with named functions:",
      "async.waterfall([",
      "\tmyFirstFunction,",
      "\tmySecondFunction,",
      "\tmyLastFunction,",
      "], function (err, result) {",
      "\t// result now equals 'done'",
      "});",
      "function myFirstFunction(callback) {",
      "\tcallback(null, 'one', 'two');",
      "}",
      "function mySecondFunction(arg1, arg2, callback) {",
      "\t// arg1 now equals 'one' and arg2 now equals 'two'",
      "\tcallback(null, 'three');",
      "}",
      "function myLastFunction(arg1, callback) {",
      "\t// arg1 now equals 'three'",
      "\tcallback(null, 'done');",
      "}"
    ],
    "description": "async waterfall method"
  },
  "whilst": {
    "prefix": ".whilst",
    "body": [
      "var count = 0;",
      "async.whilst(",
      "\tfunction() { return count < 5; },",
      "\tfunction(callback) {",
      "\t\tcount++;",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, count);",
      "\t\t}, 1000);",
      "\t},",
      "\tfunction (err, n) {",
      "\t\t// 5 seconds have passed, n = 5",
      "\t}",
      ");"
    ],
    "description": "async whilst method"
  },
  "apply": {
    "prefix": ".apply",
    "body": [
      "// using apply",
      "async.parallel([",
      "\tasync.apply(fs.writeFile, 'testfile1', 'test1'),",
      "\tasync.apply(fs.writeFile, 'testfile2', 'test2')",
      "]);",

      "// the same process without using apply",
      "async.parallel([",
      "\tfunction(callback) {",
      "\t\tfs.writeFile('testfile1', 'test1', callback);",
      "\t},",
      "\tfunction(callback) {",
      "\t\tfs.writeFile('testfile2', 'test2', callback);",
      "\t}",
      "]);",

      "// It's possible to pass any number of additional arguments when calling the",
      "// continuation:",

      "// For test",
      "// node> var fn = async.apply(sys.puts, 'one');",
      "// node> fn('two', 'three');",
      "// one",
      "// two",
      "// three"
    ],
    "description": "async apply method"
  },
  "asyncify": {
    "prefix": ".asyncify",
    "body": [
      "// passing a regular synchronous function",
      "async.waterfall([",
      "\tasync.apply(fs.readFile, filename, 'utf8'),",
      "\tasync.asyncify(JSON.parse),",
      "\tfunction (data, next) {",
      "\t\t// data is the result of parsing the text.",
      "\t\t// If there was a parsing error, it would have been caught.",
      "\t}",
      "], callback);",

      "// passing a function returning a promise",
      "async.waterfall([",
      "\tasync.apply(fs.readFile, filename, 'utf8'),",
      "\tasync.asyncify(function (contents) {",
      "\t\treturn db.model.create(contents);",
      "\t}),",
      "\tfunction (model, next) {",
      "\t\t// `model` is the instantiated model object.",
      "\t\t// If there was an error, this function would be skipped.",
      "\t}",
      "], callback);",

      "// es2017 example, though `asyncify` is not needed if your JS environment",
      "// supports async functions out of the box",
      "var q = async.queue(async.asyncify(async function(file) {",
      "\tvar intermediateStep = await processFile(file);",
      "\treturn await somePromise(intermediateStep)",
      "}));",

      "q.push(files);"
    ],
    "description": "async asyncify method"
  },
  "constant": {
    "prefix": ".constant",
    "body": [
      "async.waterfall([",
      "\tasync.constant(42),",
      "\tfunction (value, next) {",
      "\t\t// value === 42",
      "\t},",
      "\t//...",
      "], callback);",

      "async.waterfall([",
      "\tasync.constant(filename, 'utf8'),",
      "\tfs.readFile,",
      "\tfunction (fileData, next) {",
      "\t\t//...",
      "\t}",
      "\t//...",
      "], callback);",

      "async.auto({",
      "\thostname: async.constant('https://server.net/'),",
      "\tport: findFreePort,",
      "\tlaunchServer: ['hostname', 'port', function (options, cb) {",
      "\t\tstartServer(options, cb);",
      "\t}],",
      "\t//...",
      "}, callback);"
    ],
    "description": "async constant method"
  },
  "dir": {
    "prefix": ".dir",
    "body": [
      "// in a module",
      "var hello = function(name, callback) {",
      "\tsetTimeout(function() {",
      "\t\tcallback(null, {hello: name});",
      "\t}, 1000);",
      "};",

      "// in the node repl",
      "// node> async.dir(hello, 'world');",
      "// {hello: 'world'}"
    ],
    "description": "async dir method"
  },
  "ensureAsync": {
    "prefix": ".ensureAsync",
    "body": [
      "function sometimesAsync(arg, callback) {",
      "\tif (cache[arg]) {",
      "\t\treturn callback(null, cache[arg]); // this would be synchronous!!",
      "\t} else {",
      "\t\tdoSomeIO(arg, callback); // this IO would be asynchronous",
      "\t}",
      "}",

      "// this has a risk of stack overflows if many results are cached in a row",
      "async.mapSeries(args, sometimesAsync, done);",

      "// this will defer sometimesAsync's callback if necessary,",
      "// preventing stack overflows",
      "async.mapSeries(args, async.ensureAsync(sometimesAsync), done);"
    ],
    "description": "async ensureAsync method"
  },
  "log": {
    "prefix": ".log",
    "body": [
      "// in a module",
      "var hello = function(name, callback) {",
      "\tsetTimeout(function() {",
      "\t\tcallback(null, 'hello ' + name);",
      "\t}, 1000);",
      "};",

      "// in the node repl",
      "// node> async.log(hello, 'world');",
      "// 'hello world'"
    ],
    "description": "async log method"
  },
  "memoize": {
    "prefix": ".memoize",
    "body": [
      "var slow_fn = function(name, callback) {",
      "\t// do something",
      "\tcallback(null, result);",
      "};",
      "var fn = async.memoize(slow_fn);",

      "// fn can now be used as if it were slow_fn",
      "fn('some name', function() {",
      "\t// callback",
      "});"
    ],
    "description": "async memoize method"
  },
  "nextTick": {
    "prefix": ".nextTick",
    "body": [
      "var call_order = [];",
      "async.nextTick(function() {",
      "\tcall_order.push('two');",
      "\t\t// call_order now equals ['one','two']",
      "});",
      "call_order.push('one');",

      "async.setImmediate(function (a, b, c) {",
      "\t// a, b, and c equal 1, 2, and 3",
      "}, 1, 2, 3);"
    ],
    "description": "async nextTick method"
  },
  "reflect": {
    "prefix": ".reflect",
    "body": [
      "async.parallel([",
      "\tasync.reflect(function(callback) {",
      "\t\t// do some stuff ...",
      "\t\tcallback(null, 'one');",
      "\t}),",
      "\tasync.reflect(function(callback) {",
      "\t\t// do some more stuff but error ...",
      "\t\tcallback('bad stuff happened');",
      "\t}),",
      "\tasync.reflect(function(callback) {",
      "\t\t// do some more stuff ...",
      "\t\tcallback(null, 'two');",
      "\t})",
      "],",
      "// optional callback",
      "function(err, results) {",
      "\t// values",
      "\t// results[0].value = 'one'",
      "\t// results[1].error = 'bad stuff happened'",
      "\t// results[2].value = 'two'",
      "});"
    ],
    "description": "async reflect method"
  },
  "reflectAll": {
    "prefix": ".reflectAll",
    "body": [
      "let tasks = [",
      "\tfunction(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'one');",
      "\t\t}, 200);",
      "\t},",
      "\tfunction(callback) {",
      "\t\t// do some more stuff but error ...",
      "\t\tcallback(new Error('bad stuff happened'));",
      "\t},",
      "\tfunction(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'two');",
      "\t\t}, 100);",
      "\t}",
      "];",

      "async.parallel(async.reflectAll(tasks),",
      "// optional callback",
      "function(err, results) {",
      "\t// values",
      "\t// results[0].value = 'one'",
      "\t// results[1].error = Error('bad stuff happened')",
      "\t// results[2].value = 'two'",
      "});",

      "// an example using an object instead of an array",
      "let tasks = {",
      "\tone: function(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'one');",
      "\t\t}, 200);",
      "\t},",
      "\ttwo: function(callback) {",
      "\t\tcallback('two');",
      "\t},",
      "\tthree: function(callback) {",
      "\t\tsetTimeout(function() {",
      "\t\t\tcallback(null, 'three');",
      "\t\t}, 100);",
      "\t}",
      "};",

      "async.parallel(async.reflectAll(tasks),",
      "// optional callback",
      "function(err, results) {",
      "\t// values",
      "\t// results.one.value = 'one'",
      "\t// results.two.error = 'two'",
      "\t// results.three.value = 'three'",
      "});"
    ],
    "description": "async reflectAll method"
  },
  "setImmediate": {
    "prefix": ".setImmediate",
    "body": [
      "var call_order = [];",
      "async.nextTick(function() {",
      "\tcall_order.push('two');",
      "\t// call_order now equals ['one','two']",
      "});",
      "call_order.push('one');",

      "async.setImmediate(function (a, b, c) {",
      "\t// a, b, and c equal 1, 2, and 3",
      "}, 1, 2, 3);"
    ],
    "description": "async setImmediate method"
  },
  "timeout": {
    "prefix": ".timeout",
    "body": [
      "function myFunction(foo, callback) {",
      "\tdoAsyncTask(foo, function(err, data) {",
      "\t\t// handle errors",
      "\t\tif (err) return callback(err);",

      "\t\t// do some stuff ...",

      "\t\t// return processed data",
      "\t\treturn callback(null, data);",
      "\t});",
      "}",

      "var wrapped = async.timeout(myFunction, 1000);",

      "// call `wrapped` as you would `myFunction`",
      "wrapped({ bar: 'bar' }, function(err, data) {",
      "\t// if `myFunction` takes < 1000 ms to execute, `err`",
      "\t// and `data` will have their expected values",

      "\t// else `err` will be an Error with the code 'ETIMEDOUT'",
      "});"
    ],
    "description": "async timeout method"
  }
}
